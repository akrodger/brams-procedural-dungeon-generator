{
  "name": "Bram's Prodedural Dungeon Generator",
  "tagline": "An outline and code sample for how one could generate a maze",
  "body": "# Bram's Prodedural Dungeon Generator\r\nAn outline and code sample for how one could generate a maze\r\nREADME by Abram Rodgers\r\n# Contact: AKS.Rodgers (at) gmail (dot) com\r\n\r\n---------------------------------------------\r\n|An outline of my maze generating algorithm:|\r\n---------------------------------------------\r\n\r\n***\r\n        This process will take an n by m integer matrix and procedurally fill it\r\n        with paths and rooms, like a classic Rogue style maze. The algorithm is\r\n        outlined by the following instructions:\r\n\r\n        1) It is suffient to say that a room is defined by 2 points\r\n           This is because each room, in this algorithm, is a rectangle.\r\n           since rectangles have perpendicular sides,  we can spread out the sides\r\n           above/below and left/right of these 2 corners to find the other 2.\r\n           Therefore, a room can be stored as a 4 component array of integers\r\n           where an the first two and second two numbers each refer to a position\r\n           in the matrix titled maze. I will use the terms 4-component integer\r\n           array and 4-vector interchangeably.\r\n             \r\n        2) For the first room, in the 0th and 2nd components of a 4-vector,\r\n           assign random integers such that the difference of their values \r\n           is greater than 1 and they lie in the range from 0 to n - 1.Similarly, \r\n           in the first and 3rd components, assign values such that their \r\n           difference is greater than 1 and they lie in random from 0 to m - 1\r\n           Ranges are inclusive. If our vector's components are written in the\r\n           notation v = [v_0, ... , v_3] then this vector:\r\n                                       \r\n                                      v = [2, 5, 5, 7]\r\n            \r\n           Would equate to this room in a 10 by 10 matrix:\r\n               \r\n                               # # # # # # # # # #    'P' is the the location of \r\n                               # # # # # # # # # #    a generated point for a room\r\n          '#'means empty       # # # # # P - C # #    \r\n           space or Wall       # # # # # | . | # #    'C' repersents the connection\r\n                               # # # # # | . | # #    of two generated points.\r\n                               # # # # # C - P # #    \r\n                               # # # # # # # # # #    '-' and '|' are horizontal\r\n                               # # # # # # # # # #     and vertical connectors\r\n                               # # # # # # # # # #     respectively. All non-'#'\r\n                               # # # # # # # # # #     chars are walkable tiles\r\n          \r\n           Take note that these characters are not the literal value of the\r\n           matrix storing the room. I am just using them as tiles for a\r\n           visualization effect. There will be integers to represent the actual\r\n           tiles.\r\n            \r\n           Each room vector is stored in a matrix, making a matrix where\r\n           each row refers to a single room. this matrix has size \r\n           finalRooms by 4 and generating such a matrix is sufficient to creating\r\n           all of the rooms necessary for a floor.\r\n            \r\n        3) Making any room after the first one requires a bit of extra tip-toing.\r\n           We have two options, rooms can overlap or rooms may not overlap.Let us\r\n           use this function to help us:\r\n               \r\n                           int inRoom(int point[2], int room[4]);\r\n             \r\n           It will return 1 if point is enclosed by Room, 0 otherwise.\r\n           Note that in the pic above, anything point not labeled '#' returns 1.\r\n                \r\n           If we do not want rooms to overlap, we can use this function to set off\r\n           a flag which prevents goes up if a given vector would cause any tiles\r\n           from the rooms matrix to change tiles of older rooms in dungeon matrix.\r\n           See isStronglyConnected() below for further use .\r\n                \r\n           If we don't mind about overlaps, then no such extra processing is\r\n           necessary.\r\n              \r\n        4) We now have a matrix filled with rooms which are are either overlapping\r\n           or disconnected. If the rooms are overlapping, the we do not need to\r\n           connect them through hallways.If any room is disjoint from all other\r\n           rooms, then we must connect it so that one could traverse the whole\r\n           maze.It will be convenient to keep track of which rooms are\r\n           overlapping and which aren't.Define the following terms:\r\n            \r\n           Two columns of the finalRooms by 4 matrix are STRONGLY CONNECTED \r\n           if they produce overlapping rooms. Strong connectedness implies \r\n           connectedness:\r\n            \r\n           If two columns are not strongly connected, then one can CONNECT them\r\n           by producing a point which is in neither room then connecting both\r\n           rooms to that point. These rooms are called CONNECTED.\r\n                \r\n           Two rooms are connectedness is transitive. This property is stated so\r\n           that we need not necessarily connect all rooms to one another to make\r\n           a satisfactory maze. These functions will be useful:\r\n            \r\n           int isConnected(roomMatrix[][4], int room1, int room2);\r\n           checks if the rooms are transitively connected. if they are, done.\r\n           If they are not, then it checks if they are directly connected. \r\n           (through a connecting point/hallway or through strong connectedness)\r\n           The int params there are the number row of the matrix which is a room.\r\n           1 if connected, 0 otherwise.\r\n            \r\n           int isStronglyConnected(roomMatrix[][4], int room1, int room2);\r\n           similar to above, but just checks if two rooms overlap.\r\n                \r\n           int connectRooms(roomMatrix[][4], int room1, int room2);\r\n           checks if two rooms are connected, then connects them if they aren't.\r\n           return 1 if connected successfull, 0 if already connected\r\n            \r\n           We use these functions to connect all the rooms. If one room is\r\n           connected to every other room, then every room is connected to one\r\n           another. (Since connectedness is transitive.)\r\n                \r\n           To connect all the rooms, use this loop:\r\n           [1] -Check if room 0 is connected to every other room sequentially\r\n                    -if so, done\r\n               -if not, pick two arbitrary rooms.check if connected, \r\n                   -if they are, pick more arbitrary rooms until an unconnected \r\n                        pair is found\r\n                   -connect them\r\n               -go back to line [1]\r\n            \r\n        Once all rooms are connected, our maze is done.\r\n                                                                        \r\n        \r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}